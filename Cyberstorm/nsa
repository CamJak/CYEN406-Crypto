#!/bin/bash

# Get Variables

valuefile="./valuefile.dat"
PASSPHRASE="SuperDuperSecurePassphrase901"

# if we don't have a file, it has been tampered with >:(
if [ ! -f "$valuefile" ]; then
    echo "You have tampered with the file! You must begin anew. Exiting..."
	exit 1

# otherwise read the value from the file
# format: MAX_POINTS-POINTS_TOTAL-POINTS_STAGE-STAGE-NUM_STAGES-HINTS_USED-REMAINING_ATTEMPTS
else
    value_enc=$(<"$valuefile")
	value=$(echo $value_enc | openssl aes-256-cbc -d -a -pass pass:$PASSPHRASE -pbkdf2)
	IFS='-' read -r -a values <<< "$value"
	MAX_POINTS=${values[0]}
	POINTS_TOTAL=${values[1]}
	POINTS_STAGE=${values[2]}
	STAGE=${values[3]}
	NUM_STAGES=${values[4]}
	HINTS_USED=${values[5]}
	REMAINING_ATTEMPTS=${values[6]}
fi

# Set stage data

case $STAGE in
	1)
		STAGE_DESC="You have just been given an image of the device seized by the NSA. We have located an encrypted partition on the device. You must locate the script that is used to decrypt the partition. Once you have found the script, submit the hash of the file name (include the extension if available in the hash; all hashes are md5 for this challenge)."
		# Hash of the file name "mnt_part_50179"
		STAGE_ANSWER="b3e6ad45e549d4850bcaa03e1f926b6f"
		NUM_HINTS=2
		HINTS=("We believe that script is being run when the system boots, check for locations that can run files on boot." "Our forensic specialists have narrowed down some possible locations for the script, check /etc/init.d/ and the crontabs.")
		SUCCESS_MSG="Congratulations! You have found the script used to decrypt the partition! You earned $POINTS_STAGE points for this stage. Proceed to the next stage.\n"
		NEXT_STAGE_POINTS=10000
		;;
	2)
		STAGE_DESC="You have now located the script that is used to mount and decrypt the partition. To gain access to the hidden files, we need you to reverse engineer the script and determine how the script is doing the decryption. To complete this stage, you must identify the best method to attack the encryption used in the script. Once you have identified the method, submit the answer in the form of '______ attack'. (You will get only 3 attempts to answer this stage.)"
		# The answer is "dictionary attack"
		STAGE_ANSWER="dictionary attack"
		NUM_HINTS=0
		HINTS=()
		SUCCESS_MSG="That's correct! Because of the small number of possible passphrases and lack of security measures, a dictionary attack should be able to quickly crack the encryption. You earned $POINTS_STAGE points for this stage. Proceed to the next stage.\n"
		NEXT_STAGE_POINTS=20000
		MAX_ATTEMPTS=3
		;;
	3)
		STAGE_DESC=""
		STAGE_ANSWER=""
		NUM_HINTS=0
		HINTS=()
		SUCCESS_MSG=""
		NEXT_STAGE_POINTS=20000
		;;
	4)
		STAGE_DESC=""
		STAGE_ANSWER=""
		NUM_HINTS=0
		HINTS=()
		SUCCESS_MSG=""
		NEXT_STAGE_POINTS=20000
		;;
	5)
		STAGE_DESC=""
		STAGE_ANSWER=""
		NUM_HINTS=0
		HINTS=()
		SUCCESS_MSG="Congratulations! You have completed the challenge! You earned $POINTS_STAGE points for this stage. Thank you for participating!\n\n---===] Your final score is $POINTS_TOTAL! [===---\n\n"
		;;
esac

# Set attempts at new stage

if [ $STAGE -eq 2 ]; then
	if [ $REMAINING_ATTEMPTS -eq 0 ]; then
		REMAINING_ATTEMPTS=$MAX_ATTEMPTS
	fi
fi

# Functions

help_fun () {
	printf "\nWelcome to the NSA CLI!\nHere you can check your progress, request hints, and submit answers for each portion of the challenge.\n\nType commands in the form: nsa <command>\n\nCommands:\nhelp: Displays this menu.\nhint: Opens the menu for requesting a hint, and shows previous hints.\nstatus: Prints the current challenge progress and description.\nsubmit: Opens the menu for submitting the stage answer.\n"
}

hint_fun () {
	# quit if the user has already finished the challenge
	if [ $STAGE -gt $NUM_STAGES ]; then
		printf "There are no more hints, you finished the challenge!\n"
		exit 0
	fi
	# show previous hints
	if [ $HINTS_USED -gt 0 ]; then
		printf "\nPrevious hints for this stage:\n"
		for i in $(seq 1 $HINTS_USED); do
			printf "Hint $i: ${HINTS[$i-1]}\n"
		done
	fi
	# check if there are any more hints left
	if [ $HINTS_USED -ge $NUM_HINTS ]; then
		printf "\nNo more hints available for this stage.\n"
		return
	fi
	# if there are, give the user the next hint and deduct points
	printf "\nWould you like to request a hint for the current stage? Doing so will deduct from the points earned this stage. (y/n)\n"
	read -r HINT_RESPONSE
	if [ $HINT_RESPONSE = "y" ]; then
		((HINTS_USED++))
		((POINTS_STAGE-=4000))
		printf "Hint requested! You have $POINTS_STAGE points remaining this stage.\n"
		printf "Hint: ${HINTS[$HINTS_USED-1]}\n"
	else
		printf "Hint not requested.\n"
	fi
}

status_fun () {
	# check if the user has already finished the challenge
	if [ $STAGE -gt $NUM_STAGES ]; then
		printf "You have completed the challenge! Thank you for participating!\n\n---===] Your final score is $POINTS_TOTAL/$MAX_POINTS! [===---\n\n"
		exit 0
	fi
	printf "\n┌===========--------\n  Total points earned: $POINTS_TOTAL/$MAX_POINTS\n\n  Your current stage: $STAGE/$NUM_STAGES\n\n  $STAGE_DESC\n\n  Hints used this stage: $HINTS_USED\n  Points remaining this stage: $POINTS_STAGE\n└===========--------\n"
}

submit_fun () {
	# check if the user has already finished the challenge
	if [ $STAGE -gt $NUM_STAGES ]; then
		printf "You have already completed the challenge. Thank you for participating!\n\n---===] Your final score is $POINTS_TOTAL! [===---\n\n"
		exit 0
	fi
	# check if the current stage is stage 2
	if [ $STAGE -eq 2 ]; then
		printf "\nYou have $REMAINING_ATTEMPTS attempts remaining for this stage.\n"
	fi
	# verify answer
	printf "\nPlease enter your answer for stage $STAGE: "
	read -r SUBMIT_RESPONSE
	SUBMIT_LOWER=$(echo $SUBMIT_RESPONSE | tr '[:upper:]' '[:lower:]')
	# if the answer is correct
	if [ "$SUBMIT_LOWER" = "$STAGE_ANSWER" ]; then
		# check if this is the final stage
		if [ $STAGE -eq $NUM_STAGES ]; then
			((POINTS_TOTAL+=$POINTS_STAGE))
			((STAGE++))
			printf "$SUCCESS_MSG"
		else
			((POINTS_TOTAL+=$POINTS_STAGE))
			((STAGE++))
			((POINTS_STAGE=$NEXT_STAGE_POINTS))
			((HINTS_USED=0))
			printf "$SUCCESS_MSG"
		fi
	# if the answer is incorrect
	else
		# check if the current stage has limited attempts
		if [ $STAGE -eq 2 ]; then
			((REMAINING_ATTEMPTS--))
			if [ $REMAINING_ATTEMPTS -eq 0 ]; then
				printf "Incorrect answer. You have no more attempts remaining. The correct answer was 'Dictionary Attack'. You will be automatically moved on to the next stage.\n"
				((STAGE++))
				((REMAINING_ATTEMPTS=0))
				((HINTS_USED=0))
				((POINTS_STAGE=$NEXT_STAGE_POINTS))
				return
			fi
			printf "Incorrect answer. You have $REMAINING_ATTEMPTS attempts remaining.\n"
		else
			printf "Incorrect answer. Please try again.\n"
		fi
	fi
}

# Process args and run functions

if [ $# = 1 ]; then
	case $1 in
		"help")
			help_fun
			;;
		"hint")
			hint_fun
			;;
		"status")
			status_fun
			;;
		"submit")
			submit_fun
			;;
	esac
else
	printf "Invalid Arguments: Try 'nsa help' for more information.\n"
fi

# Save vars to file
# format: MAX_POINTS-POINTS_TOTAL-POINTS_STAGE-STAGE-NUM_STAGES-HINTS_USED-REMAINING_ATTEMPTS

# encrypt the data
DATA=("$MAX_POINTS-$POINTS_TOTAL-$POINTS_STAGE-$STAGE-$NUM_STAGES-$HINTS_USED-$REMAINING_ATTEMPTS")
ENC_DATA=$(echo -n "${DATA[0]}" | openssl aes-256-cbc -a -salt -pass pass:$PASSPHRASE -pbkdf2)

# store the encrypted data
echo -n $ENC_DATA > "$valuefile"